AWSTemplateFormatVersion: '2010-09-09'
Description: 'AI Chef Price Lambda Function - Python Version'

Resources:
  # Lambda Execution Role
  PriceLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource: 
                  - !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/ai-chef-sessions'

  # Price Lambda Function
  PriceLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: 'ai-chef-price'
      Runtime: python3.11
      Handler: lambda_function.lambda_handler
      Role: !GetAtt PriceLambdaRole.Arn
      Timeout: 30
      MemorySize: 256
      Environment:
        Variables:
          NAVER_CLIENT_ID: '5A_tDnltTaEiCEsXbHH7'
          NAVER_CLIENT_SECRET: 'ygjYjr9oqc'
          SESSIONS_TABLE_NAME: 'ai-chef-sessions'
      Code:
        ZipFile: |
          import json
          import urllib.request
          import urllib.parse
          import boto3
          import os
          from datetime import datetime
          from typing import Dict, List, Any

          # AWS 리소스 초기화
          dynamodb = boto3.resource('dynamodb', region_name='us-east-1')
          sessions_table = dynamodb.Table('ai-chef-sessions')

          def lambda_handler(event: Dict[str, Any], context) -> Dict[str, Any]:
              """Price Lambda handler - Recipe Lambda 스타일"""
              try:
                  session_id = event.get('sessionId')
                  ingredients = event.get('ingredients', [])
                  
                  if not ingredients or not session_id:
                      raise ValueError('ingredients and sessionId required')
                  
                  # 세션 상태 업데이트
                  update_session_status(session_id, 'processing', 'price_lookup', 60)
                  
                  # 재료별 가격 조회
                  price_results = {}
                  for ingredient in ingredients:
                      ingredient_name = ingredient if isinstance(ingredient, str) else ingredient.get('name', ingredient)
                      price_results[ingredient_name] = get_ingredient_prices(ingredient_name)
                  
                  # 응답 데이터 구성
                  result = format_pricing_result(price_results, session_id)
                  
                  # DynamoDB 저장
                  save_price_data(session_id, result)
                  
                  # 세션 상태 완료
                  update_session_status(session_id, 'processing', 'price_completed', 80)
                  
                  return {
                      'statusCode': 200,
                      'headers': {
                          'Content-Type': 'application/json; charset=utf-8'
                      },
                      'body': result
                  }
                  
              except Exception as e:
                  update_session_status(session_id, 'failed', 'price_lookup_failed', 60, str(e))
                  return {
                      'statusCode': 500,
                      'body': {
                          'success': False,
                          'error': str(e)
                      }
                  }

          def get_ingredient_prices(ingredient_name: str) -> List[Dict]:
              """네이버 쇼핑 API로 가격 조회 - 0원만 필터링"""
              client_id = os.environ.get('NAVER_CLIENT_ID', '5A_tDnltTaEiCEsXbHH7')
              client_secret = os.environ.get('NAVER_CLIENT_SECRET', 'ygjYjr9oqc')
              
              # 한글 인코딩 수정
              query = urllib.parse.quote(ingredient_name)
              url = f"https://openapi.naver.com/v1/search/shop.json?query={query}&display=20&sort=asc"
              
              request = urllib.request.Request(url)
              request.add_header("X-Naver-Client-Id", client_id)
              request.add_header("X-Naver-Client-Secret", client_secret)
              
              try:
                  with urllib.request.urlopen(request, timeout=5) as response:
                      # UTF-8 디코딩 명시
                      data = json.loads(response.read().decode('utf-8'))
                  
                  prices = []
                  for item in data.get('items', []):
                      # 한글 제목 정리
                      title = item.get('title', '').replace('<b>', '').replace('</b>', '')
                      price = int(item.get('lprice', 0))
                      
                      # 0원 상품만 필터링
                      if price <= 0:
                          continue
                      
                      prices.append({
                          'name': title,
                          'price': price,
                          'vendor': item.get('mallName', ''),
                          'link': item.get('link', ''),
                          'image': item.get('image', ''),
                          'category': item.get('category1', ''),
                          'productId': item.get('productId', ''),
                          'brand': item.get('brand', ''),
                          'availability': 'available'
                      })
                  
                  # 가격순 정렬 후 상위 10개만 반환
                  sorted_prices = sorted(prices, key=lambda x: x['price'])
                  return sorted_prices[:10]
                  
              except Exception as e:
                  print(f'재료 {ingredient_name} 조회 실패: {e}')
                  return []

          def format_pricing_result(price_results: Dict[str, List], session_id: str) -> Dict:
              """가격 결과 포맷팅"""
              found_ingredients = [k for k, v in price_results.items() if v]
              total_cost = sum(items[0]['price'] for items in price_results.values() if items)
              
              return {
                  'success': True,
                  'data': {
                      'summary': {
                          'totalIngredients': len(price_results),
                          'foundIngredients': len(found_ingredients),
                          'successRate': len(found_ingredients) / len(price_results) if price_results else 0
                      },
                      'ingredients': price_results,
                      'recommendations': {
                          'totalEstimatedCost': total_cost,
                          'optimalVendors': calculate_optimal_vendors(price_results)
                      }
                  },
                  'metadata': {
                      'timestamp': datetime.now().isoformat(),
                      'sessionId': session_id
                  }
              }

          def calculate_optimal_vendors(price_results: Dict[str, List]) -> List[Dict]:
              """최적 판매처 계산"""
              vendor_groups = {}
              
              for ingredient, items in price_results.items():
                  if not items:
                      continue
                      
                  cheapest = items[0]
                  vendor = cheapest['vendor']
                  
                  if vendor not in vendor_groups:
                      vendor_groups[vendor] = {'items': [], 'totalPrice': 0, 'itemCount': 0}
                  
                  vendor_groups[vendor]['items'].append({'ingredient': ingredient, **cheapest})
                  vendor_groups[vendor]['totalPrice'] += cheapest['price']
                  vendor_groups[vendor]['itemCount'] += 1
              
              return [{'vendor': vendor, **data} for vendor, data in vendor_groups.items()]

          def update_session_status(session_id: str, status: str, phase: str, progress: int, error: str = None):
              """세션 상태 업데이트 - Recipe Lambda 스타일"""
              try:
                  update_expression = "SET #status = :status, #phase = :phase, #progress = :progress, #updatedAt = :updatedAt"
                  expression_values = {
                      ':status': status,
                      ':phase': phase,
                      ':progress': progress,
                      ':updatedAt': datetime.now().isoformat()
                  }
                  expression_names = {
                      '#status': 'status',
                      '#phase': 'phase',
                      '#progress': 'progress',
                      '#updatedAt': 'updatedAt'
                  }
                  
                  if error:
                      update_expression += ", #error = :error"
                      expression_values[':error'] = error[:1000]
                      expression_names['#error'] = 'error'
                  
                  sessions_table.update_item(
                      Key={'sessionId': session_id},
                      UpdateExpression=update_expression,
                      ExpressionAttributeNames=expression_names,
                      ExpressionAttributeValues=expression_values
                  )
                  
              except Exception as e:
                  print(f"Failed to update session status: {e}")

          def save_price_data(session_id: str, result_data: Dict):
              """가격 데이터 저장 - Recipe Lambda 스타일"""
              try:
                  # 데이터 크기 제한
                  data_str = json.dumps(result_data['data'])
                  if len(data_str) > 350000:  # 350KB 제한
                      # 재료당 5개만 저장
                      truncated_ingredients = {
                          k: v[:5] for k, v in result_data['data']['ingredients'].items()
                      }
                      result_data['data']['ingredients'] = truncated_ingredients
                  
                  sessions_table.update_item(
                      Key={'sessionId': session_id},
                      UpdateExpression="SET #priceData = :priceData, #priceUpdatedAt = :updatedAt",
                      ExpressionAttributeNames={
                          '#priceData': 'priceData',
                          '#priceUpdatedAt': 'priceUpdatedAt'
                      },
                      ExpressionAttributeValues={
                          ':priceData': result_data['data'],
                          ':updatedAt': datetime.now().isoformat()
                      }
                  )
                  
              except Exception as e:
                  print(f"Failed to save price data: {e}")

Outputs:
  PriceLambdaArn:
    Description: 'Price Lambda Function ARN'
    Value: !GetAtt PriceLambda.Arn
    Export:
      Name: !Sub '${AWS::StackName}-PriceLambdaArn'
