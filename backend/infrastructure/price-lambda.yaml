AWSTemplateFormatVersion: '2010-09-09'
Description: 'AI Chef Price Lambda Function - Python Version'

Resources:
  # Lambda Execution Role
  PriceLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource: 
                  - !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/ai-chef-sessions'

  # Price Lambda Function
  PriceLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: 'ai-chef-price'
      Runtime: python3.11
      Handler: lambda_function.lambda_handler
      Role: !GetAtt PriceLambdaRole.Arn
      Timeout: 30
      MemorySize: 256
      Environment:
        Variables:
          NAVER_CLIENT_ID: '5A_tDnltTaEiCEsXbHH7'
          NAVER_CLIENT_SECRET: 'ygjYjr9oqc'
          SESSIONS_TABLE_NAME: 'ai-chef-sessions'
      Code:
        ZipFile: |
          import json
          import urllib.request
          import urllib.parse
          import boto3
          import os
          from datetime import datetime

          dynamodb = boto3.resource('dynamodb', region_name='us-east-1')
          sessions_table = dynamodb.Table('ai-chef-sessions')

          def lambda_handler(event, context):
              try:
                  session_id = event.get('sessionId')
                  ingredients = event.get('ingredients', [])
                  
                  if not ingredients or not session_id:
                      raise ValueError('ingredients and sessionId required')
                  
                  # 재료별 가격 조회
                  price_results = {}
                  for ingredient in ingredients:
                      ingredient_name = ingredient if isinstance(ingredient, str) else ingredient.get('name', ingredient)
                      price_results[ingredient_name] = get_ingredient_prices(ingredient_name)
                  
                  # 응답 데이터 구성
                  found_ingredients = [k for k, v in price_results.items() if v]
                  total_cost = sum(items[0]['price'] for items in price_results.values() if items)
                  
                  result = {
                      'success': True,
                      'data': {
                          'summary': {
                              'totalIngredients': len(price_results),
                              'foundIngredients': len(found_ingredients),
                              'successRate': len(found_ingredients) / len(price_results) if price_results else 0
                          },
                          'ingredients': price_results,
                          'recommendations': {'totalEstimatedCost': total_cost}
                      },
                      'metadata': {
                          'timestamp': datetime.now().isoformat(),
                          'sessionId': session_id
                      }
                  }
                  
                  return {
                      'statusCode': 200,
                      'headers': {'Content-Type': 'application/json; charset=utf-8'},
                      'body': result
                  }
                  
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': {'success': False, 'error': str(e)}
                  }

          def get_ingredient_prices(ingredient_name):
              client_id = os.environ.get('NAVER_CLIENT_ID')
              client_secret = os.environ.get('NAVER_CLIENT_SECRET')
              
              query = urllib.parse.quote(ingredient_name)
              url = f"https://openapi.naver.com/v1/search/shop.json?query={query}&display=10&sort=asc"
              
              request = urllib.request.Request(url)
              request.add_header("X-Naver-Client-Id", client_id)
              request.add_header("X-Naver-Client-Secret", client_secret)
              
              try:
                  with urllib.request.urlopen(request, timeout=5) as response:
                      data = json.loads(response.read().decode('utf-8'))
                  
                  prices = []
                  for item in data.get('items', []):
                      title = item.get('title', '').replace('<b>', '').replace('</b>', '')
                      price = int(item.get('lprice', 0))
                      
                      if price <= 0:
                          continue
                      
                      prices.append({
                          'name': title,
                          'price': price,
                          'vendor': item.get('mallName', ''),
                          'link': item.get('link', ''),
                          'image': item.get('image', ''),
                          'category': item.get('category1', ''),
                          'productId': item.get('productId', ''),
                          'brand': item.get('brand', ''),
                          'availability': 'available'
                      })
                  
                  return sorted(prices, key=lambda x: x['price'])[:10]
                  
              except Exception as e:
                  print(f'재료 {ingredient_name} 조회 실패: {e}')
                  return []

Outputs:
  PriceLambdaArn:
    Description: 'Price Lambda Function ARN'
    Value: !GetAtt PriceLambda.Arn
    Export:
      Name: !Sub '${AWS::StackName}-PriceLambdaArn'
